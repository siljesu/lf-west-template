target C {
    platform: {
        name: Zephyr,
        board: mimxrt1170_evk_cm7,
        port: /dev/enp4s0f2
     },
    no-compile: true,
    coordination: decentralized,
    workers: 2,
}


reactor DistAlg(ownId:int(0)) {
    preamble {=
        void findIndexSmallestValues(int* arr, int* closestArr, int n) {
            int min1 = arr[0];
            int pos1 = 0;
            int min2 = arr[1];
            int pos2 = 1;

            if (min2 < min1) {
                min1 = arr[1];
                pos1 = 1;
                min2 = arr[0];
                pos2 = 0;
            }
            for (int i = 2; i < n; i++) {
                if (arr[i] < min1) {
                    min2 = min1;
                    pos2 = pos1;
                    min1 = arr[i];
                    pos1 = i;
                } else if (arr[i] < min2) {
                    min2 = arr[i];
                    pos2 = i;
                }
            }
            closestArr[0] = pos1;
            closestArr[1] = pos2;
        }

        int localAction(int closestRelays[], int ownId) {
            if (ownId == closestRelays[0] || ownId == closestRelays[1]) {
                //printf("This relay should open, disconnecting the grid.\n");
                return 1;
            } else {
                //printf("This relay should close, connecting the grid.\n");
                return 0;
            }
        }

        int decideLocalAction(int* arr, int ownId, int numUnits) {
            int closestRelays[2];
            findIndexSmallestValues(arr, closestRelays, numUnits);
            return localAction(closestRelays, ownId);
        }
    =}

    output distributedDecision:int
    input voltageReportAIn:int
    input voltageReportBIn:int
    input voltageReportCIn:int
    input voltageReportDIn:int

    reaction(voltageReportAIn, voltageReportBIn, voltageReportCIn, voltageReportDIn) -> distributedDecision {=
        bool result = 1; // default open
        //printf("Entering algorithm.\n");
        
        //debugging
        // if (voltageReportAIn->is_present) {
        //     printf("Input from A was present.\n");
        // } else {
        //     printf("Input from A was not present.\n");
        // }

        // if (voltageReportBIn->is_present) {
        //     printf("Input from B was present.\n");
        // } else {
        //     printf("Input from B was not present.\n");
        // }

        // if (voltageReportCIn->is_present) {
        //     printf("Input from C was present.\n");
        // } else {
        //     printf("Input from C was not present.\n");
        // }

        // if (voltageReportDIn->is_present) {
        //     printf("Input from D was present.\n");
        // } else {
        //     printf("Input from D was not present.\n");
        // }

        if (voltageReportAIn->is_present && voltageReportBIn->is_present && voltageReportCIn->is_present && voltageReportDIn->is_present) {
            int voltageReports[4] = {voltageReportAIn->value, voltageReportBIn->value, voltageReportCIn->value, voltageReportDIn->value};
            result = decideLocalAction(voltageReports, self->ownId, 4);
            //printf("Setting relay %u to %u (1=open,0=close)\n", self->ownId, result);
            lf_set(distributedDecision, result);
        }
    =} STP(0) {=
        printf("STP violation: Did not receive inputs in time, opening circuit as default.\n");
    =}
}

reactor CircuitStatus {
    preamble {=
        #include <zephyr/kernel.h>
        #include <zephyr/drivers/gpio.h>
        #define LED0_NODE DT_ALIAS(led0)
        static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

        void openCircuit() {
            // led turns on
            gpio_pin_set_dt(&led, 0);
        }

        void closeCircuit() {
            // led turns off
            gpio_pin_set_dt(&led, 1);
        }
    =}

    input distributedDecision:int
    input countdown:int
    logical action breakCircuit;
    state faultHandled:int;

    reaction(startup){=
        assert(device_is_ready(led.port));
        gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
    =}

    reaction(countdown) -> breakCircuit {=
        //printf("Starting countdown to automatic open relay (breaking circuit). 5 sec.\n");
        self->faultHandled = 0;
        lf_schedule(breakCircuit, MSEC(150));
    =}

    reaction(breakCircuit) {=
        if (self->faultHandled){
            // This relay is not the closest to the fault
            //printf("Fault handled elsewhere, so not breaking circuit\n");
        } else {
            //printf("Opening relay (breaking circuit).\n");
            openCircuit();
        }
    =}

    reaction(distributedDecision) -> breakCircuit {=
        if (distributedDecision->value) {
            //printf("Algorithm decided to open this relay, breaking the circuit.\n");
            openCircuit();
            self->faultHandled = 1;
        } else {
            //printf("Algorithm decided to close this relay. Fault has been handled by another relay.\n");
            closeCircuit();
            self->faultHandled = 1;
        }
    =}
}

reactor VoltageSensor(id:int(0)) {

    preamble{=

        #include <zephyr/kernel.h>
        #include <zephyr/drivers/gpio.h>
        static const struct gpio_dt_spec led2 = GPIO_DT_SPEC_GET(DT_PATH(leds,led_2), gpios);
        const struct device *const gpio_dev = DEVICE_DT_GET(DT_NODELABEL(gpio9));

        #define VOLTAGE_LIMIT 14000U

        // Voltage measurement timeseries
        int simMeas[4][14] ={{15000,15000,13100,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,11000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,11200,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,12500,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000}};

        int readSensor(int id, int count) {
            //printf("Read %u\n", simMeas[id][count]);
            return simMeas[id][count];
        }
    =}

    timer t(1 sec, 100 msec);
    output[4] measOut:int
    output startCountdown:int
    state measCount:int(0)

    reaction(startup){=
        assert(device_is_ready(led2.port));
        assert(device_is_ready(gpio_dev));
        gpio_pin_configure_dt(&led2, GPIO_OUTPUT_ACTIVE);
        gpio_pin_configure(gpio_dev, 5, GPIO_OUTPUT); 
        gpio_pin_set_dt(&led2, 0);
        gpio_pin_set(gpio_dev, 5, 1);
    =}

    reaction(t) -> measOut, startCountdown {=

        // Read simulated measurement 
        int voltageMeasurement = readSensor(self->id, self->measCount);
        if (self->measCount == 13) {
            self->measCount = 0;
            lf_request_stop();
        } else {
            self->measCount++;
        }

        // Check if short circuit has occured on the line
        if (voltageMeasurement < VOLTAGE_LIMIT) {
            gpio_pin_set_dt(&led2, 1);
            gpio_pin_set(gpio_dev, 5, 0);
            // A fault has occured, let other nodes know
            //printf("Measurement was under limit.\n");
            lf_set(startCountdown, 1);
            for (int i = 0; i < 4; i++) {
                lf_set(measOut[i], voltageMeasurement);
                //etter reaksjon settes dette ^
                // ny reaktor som kalles network som simulerer forsinkelse
            }
        }
    =}
}

reactor RelayUnit(id:int(0)) {
    output[4] voltageReportOut:int;
    input voltageReportAIn:int;
    input voltageReportBIn:int;
    input voltageReportCIn:int;
    input voltageReportDIn:int;

    circuitStatus = new CircuitStatus();
    voltageSensor = new VoltageSensor(id = id);
    distAlg = new DistAlg(ownId = id);

    voltageSensor.measOut -> voltageReportOut;
    voltageSensor.startCountdown -> circuitStatus.countdown;

    voltageReportAIn -> distAlg.voltageReportAIn;
    voltageReportBIn -> distAlg.voltageReportBIn;
    voltageReportCIn -> distAlg.voltageReportCIn;
    voltageReportDIn -> distAlg.voltageReportDIn;

    
    distAlg.distributedDecision -> circuitStatus.distributedDecision;

}

federated reactor at 192.0.2.2:15047 {
    unitA = new RelayUnit(id = 0);
    unitB = new RelayUnit(id = 1);
    unitC = new RelayUnit(id = 2);
    unitD = new RelayUnit(id = 3);

    unitA.voltageReportOut -> unitA.voltageReportAIn, 
                              unitB.voltageReportAIn, 
                              unitC.voltageReportAIn, 
                              unitD.voltageReportAIn after 50 msec;

    unitB.voltageReportOut -> unitA.voltageReportBIn, 
                              unitB.voltageReportBIn, 
                              unitC.voltageReportBIn, 
                              unitD.voltageReportBIn after 50 msec;

    unitC.voltageReportOut -> unitA.voltageReportCIn, 
                              unitB.voltageReportCIn, 
                              unitC.voltageReportCIn, 
                              unitD.voltageReportCIn after 50 msec;

    unitD.voltageReportOut -> unitA.voltageReportDIn, 
                              unitB.voltageReportDIn, 
                              unitC.voltageReportDIn, 
                              unitD.voltageReportDIn after 50 msec;
}
