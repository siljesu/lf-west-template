target C {
     threading: true,
     workers: 2,
     //coordination: decentralized,
}

reactor Source(period: time(2 sec), iterations:int(10)) {
    output y: int
    timer t(1 sec, period)
    state count: int(0)

    reaction(startup) {=
    =}

    reaction(t) -> y {=
        (self->count)++;
        lf_set(y, self->count);
        if (self->count == self->iterations) {
            lf_request_stop();
        }
    =}

    reaction(shutdown) {=
        printf("Finished %u iterations. Requesting stop.\n", self->count);
    =}
}

reactor Drain {
    input x: int
    state count: int(0)

    reaction(startup) {=
        printf("Starting first iteration at %u.\n", self->count, lf_time_physical_elapsed());
    =}

    reaction(x) {=
        (self->count)++;
        if (self->count != x->value) {
            printf("Received wrong message: %u. Expected: %u. Requesting stop.\n", x->value, self->count);
            lf_request_stop();
        } else {
        }
    =}

    reaction(shutdown) {=
        printf("Finished %u iterations in %u. Stopping.\n", self->count, lf_time_physical_elapsed());
    =}
}

reactor Print {
    reaction(startup) {=
    =}
}

federated reactor at 192.0.2.3:15047 {
    s = new Source(period = 100 msec, iterations = 300); // 3 msec for lite. Buffere fylles opp raskere enn de tÃ¸mmes?
    d = new Drain();
    //p = new Print();
    s.y -> d.x;
}
